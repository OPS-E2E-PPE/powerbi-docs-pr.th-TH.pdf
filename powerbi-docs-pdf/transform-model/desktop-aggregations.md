---
title: ใช้และจัดการการรวมข้อมูลใน Power BI Desktop
description: ใช้การรวมข้อมูลเพื่อดำเนินการวิเคราะห์แบบโต้ตอบกับข้อมูลขนาดใหญ่ใน Power BI Desktop
author: davidiseminger
ms.author: davidi
ms.reviewer: ''
ms.service: powerbi
ms.subservice: pbi-transform-model
ms.topic: conceptual
ms.date: 02/14/2020
LocalizationGroup: Transform and shape data
ms.openlocfilehash: a6adf2136cbff1df6e673de16fd1673127df0192
ms.sourcegitcommit: 653e18d7041d3dd1cf7a38010372366975a98eae
ms.translationtype: HT
ms.contentlocale: th-TH
ms.lasthandoff: 12/01/2020
ms.locfileid: "96416312"
---
# <a name="use-aggregations-in-power-bi-desktop"></a><span data-ttu-id="71653-103">ใช้การรวมข้อมูลใน Power BI Desktop</span><span class="sxs-lookup"><span data-stu-id="71653-103">Use aggregations in Power BI Desktop</span></span>

<span data-ttu-id="71653-104">*การรวมข้อมูล* ใน Power BI ช่วยคุณลดขนาดตารางเพื่อให้คุณสามารถเน้นข้อมูลที่สำคัญและปรับปรุงประสิทธิภาพของคิวรีได้</span><span class="sxs-lookup"><span data-stu-id="71653-104">*Aggregations* in Power BI let you reduce table sizes so you can focus on important data and improve query performance.</span></span> <span data-ttu-id="71653-105">การรวมข้อมูลเปิดใช้งานการวิเคราะห์แบบโต้ตอบกับข้อมูลขนาดใหญ่ในรูปแบบที่วิธีการอื่นไม่สามารถทำได้ และสามารถลดค่าใช้จ่ายในการปลดล็อกชุดข้อมูลขนาดใหญ่สำหรับการตัดสินใจได้อย่างมาก</span><span class="sxs-lookup"><span data-stu-id="71653-105">Aggregations enable interactive analysis over big data in ways that aren't possible otherwise, and can dramatically reduce the cost of unlocking large datasets for decision making.</span></span>

<span data-ttu-id="71653-106">ประโยชน์บางอย่างของการใช้การรวมข้อมูล ได้แก่:</span><span class="sxs-lookup"><span data-stu-id="71653-106">Some advantages of using aggregations include:</span></span>

- <span data-ttu-id="71653-107">**ประสิทธิภาพของคิวรีกับข้อมูลขนาดใหญ่ดียิ่งขึ้น**</span><span class="sxs-lookup"><span data-stu-id="71653-107">**Better query performance over big data**.</span></span> <span data-ttu-id="71653-108">ทุกการโต้ตอบกับวิชวล Power BI จะส่งคิวรี DAX ไปยังชุดข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-108">Every interaction with Power BI visuals submits DAX queries to the dataset.</span></span> <span data-ttu-id="71653-109">ข้อมูลรวมที่เก็บไว้ในแคชใช้ทรัพยากรเพียงส่วนน้อย ซึ่งจำเป็นสำหรับข้อมูลรายละเอียดเพื่อให้คุณสามารถปลดล็อกข้อมูลขนาดใหญ่ที่จะไม่สามารถเข้าถึงได้</span><span class="sxs-lookup"><span data-stu-id="71653-109">Cached aggregated data uses a fraction of the resources required for detail data, so you can unlock big data that would otherwise be inaccessible.</span></span>
- <span data-ttu-id="71653-110">**การรีเฟรชข้อมูลที่เหมาะสม**</span><span class="sxs-lookup"><span data-stu-id="71653-110">**Optimized data refresh**.</span></span> <span data-ttu-id="71653-111">ขนาดแคชที่เล็กลงช่วยลดเวลาในการรีเฟรช ดังนั้นข้อมูลจะเข้าถึงผู้ใช้เร็วขึ้น</span><span class="sxs-lookup"><span data-stu-id="71653-111">Smaller cache sizes reduce refresh times, so data gets to users faster.</span></span>
- <span data-ttu-id="71653-112">**สถาปัตยกรรมที่สมดุล**</span><span class="sxs-lookup"><span data-stu-id="71653-112">**Balanced architectures**.</span></span> <span data-ttu-id="71653-113">แคช Power BI ในหน่วยความจำสามารถจัดการคิวรีรวม จำกัดคิวรีที่ส่งในโหมด DirectQuery และและช่วยให้คุณตอบสนองขีดจำกัดการทำงานพร้อมกัน</span><span class="sxs-lookup"><span data-stu-id="71653-113">The Power BI in-memory cache can handle aggregated queries, limiting queries sent in DirectQuery mode and helping you meet concurrency limits.</span></span> <span data-ttu-id="71653-114">คิวรีระดับรายละเอียดที่เหลืออยู่มีแนวโน้มที่จะถูกกรอง คิวรีระดับทรานแซคชัน ซึ่งโดยปกติคลังข้อมูลและระบบข้อมูลขนาดใหญ่จะจัดการได้ดี</span><span class="sxs-lookup"><span data-stu-id="71653-114">The remaining detail-level queries tend to be filtered, transactional-level queries, which data warehouses and big-data systems normally handle well.</span></span>

![การรวมข้อมูลใน Microsoft Power BI Desktop](media/desktop-aggregations/aggregations_07.jpg)

<span data-ttu-id="71653-116">แหล่งข้อมูลแบบมิติ เช่น คลังข้อมูลและตลาดข้อมูล สามารถใช้[การรวมอิงตามความสัมพันธ์](#aggregation-based-on-relationships)ได้</span><span class="sxs-lookup"><span data-stu-id="71653-116">Dimensional data sources, like data warehouses and data marts, can use [relationship-based aggregations](#aggregation-based-on-relationships).</span></span> <span data-ttu-id="71653-117">แหล่งข้อมูลขนาดใหญ่ที่ใช้ Hadoop มัก[มาจากฐานการรวมข้อมูลบนคอลัมน์ GroupBy](#aggregation-based-on-groupby-columns)</span><span class="sxs-lookup"><span data-stu-id="71653-117">Hadoop-based big-data sources often [base aggregations on GroupBy columns](#aggregation-based-on-groupby-columns).</span></span> <span data-ttu-id="71653-118">บทความนี้จะอธิบายเกี่ยวกับความแตกต่างของการสร้างแบบจำลอง Power BI ทั่วไปสำหรับแต่ละชนิดของแหล่งข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-118">This article describes typical Power BI modeling differences for each type of data source.</span></span>

## <a name="create-an-aggregated-table"></a><span data-ttu-id="71653-119">สร้างตารางรวม</span><span class="sxs-lookup"><span data-stu-id="71653-119">Create an aggregated table</span></span>

<span data-ttu-id="71653-120">เพื่อสร้างตารางรวม:</span><span class="sxs-lookup"><span data-stu-id="71653-120">To create an aggregated table:</span></span>
1. <span data-ttu-id="71653-121">ตั้งค่าตารางใหม่ด้วยเขตข้อมูลที่คุณต้องการ โดยขึ้นอยู่กับแหล่งข้อมูลและแบบจำลองของคุณ</span><span class="sxs-lookup"><span data-stu-id="71653-121">Set up a new table with the fields you want, depending on your data source and model.</span></span> 
1. <span data-ttu-id="71653-122">กำหนดการรวมข้อมูลโดยใช้กล่องโต้ตอบ **จัดการการรวมข้อมูล**</span><span class="sxs-lookup"><span data-stu-id="71653-122">Define the aggregations by using the **Manage aggregations** dialog.</span></span>
1. <span data-ttu-id="71653-123">หากเป็นไปได้ ให้เปลี่ยน[โหมดที่เก็บข้อมูล](#storage-modes) สำหรับตารางรวม</span><span class="sxs-lookup"><span data-stu-id="71653-123">If applicable, change the [storage mode](#storage-modes) for the aggregated table.</span></span> 

### <a name="manage-aggregations"></a><span data-ttu-id="71653-124">จัดการการรวม</span><span class="sxs-lookup"><span data-stu-id="71653-124">Manage aggregations</span></span>

<span data-ttu-id="71653-125">หลังจากที่คุณสร้างตารางใหม่ที่มีเขตข้อมูลที่คุณต้องการแล้ว ในบานหน้าต่าง **เขตข้อมูล** ของมุมมอง Power BI Desktop ให้คลิกขวาที่ตาราง และเลือก **จัดการการรวมข้อมูล**</span><span class="sxs-lookup"><span data-stu-id="71653-125">After you create the new table that has the fields you want, in the **Fields** pane of any Power BI Desktop view, right-click the table, and select **Manage aggregations**.</span></span>

![เลือกจัดการการรวมข้อมูล](media/desktop-aggregations/aggregations-06.png)

<span data-ttu-id="71653-127">กล่องโต้ตอบ **จัดการการรวมข้อมูล** แสดงแถวของแต่ละคอลัมน์ในตาราง ซึ่งคุณสามารถระบุลักษณะการทำงานของการรวมข้อมูลได้</span><span class="sxs-lookup"><span data-stu-id="71653-127">The **Manage aggregations** dialog shows a row for each column in the table, where you can specify the aggregation behavior.</span></span> <span data-ttu-id="71653-128">ในตัวอย่างต่อไปนี้ การคิวรีไปยังตารางรายละเอียด **Sales** จะถูกเปลี่ยนเส้นทางภายในไปยังตารางการรวม **Sales Agg**</span><span class="sxs-lookup"><span data-stu-id="71653-128">In the following example, queries to the **Sales** detail table are internally redirected to the **Sales Agg** aggregation table.</span></span> 

<span data-ttu-id="71653-129">เมนูดรอปดาวน์ **การสรุป** ในกล่องโต้ตอบ **จัดการการรวมข้อมูล** มีค่าต่อไปนี้:</span><span class="sxs-lookup"><span data-stu-id="71653-129">The **Summarization** drop-down in the **Manage aggregations** dialog offers the following values:</span></span>
- <span data-ttu-id="71653-130">Count</span><span class="sxs-lookup"><span data-stu-id="71653-130">Count</span></span>
- <span data-ttu-id="71653-131">จัดกลุ่มตาม</span><span class="sxs-lookup"><span data-stu-id="71653-131">GroupBy</span></span>
- <span data-ttu-id="71653-132">ค่าสูงสุด</span><span class="sxs-lookup"><span data-stu-id="71653-132">Max</span></span>
- <span data-ttu-id="71653-133">ค่าต่ำสุด</span><span class="sxs-lookup"><span data-stu-id="71653-133">Min</span></span>
- <span data-ttu-id="71653-134">Sum</span><span class="sxs-lookup"><span data-stu-id="71653-134">Sum</span></span>
- <span data-ttu-id="71653-135">นับแถวของตาราง</span><span class="sxs-lookup"><span data-stu-id="71653-135">Count table rows</span></span>

![สกรีนช็อตแสดงกล่องโต้ตอบจัดการการรวม](media/desktop-aggregations/aggregations_07.jpg)

<span data-ttu-id="71653-137">ในตัวอย่างการรวมอิงตามความสัมพันธ์นี้ รายการ GroupBy เป็นทางเลือก</span><span class="sxs-lookup"><span data-stu-id="71653-137">In this relationship-based aggregation example, the GroupBy entries are optional.</span></span> <span data-ttu-id="71653-138">ยกเว้นสำหรับ DISTINCTCOUNT วิธีการนี้จะไม่ส่งผลกระทบต่อลักษณะการทำงานของการรวมข้อมูล และเพื่อความสามารถในการอ่านเป็นหลัก</span><span class="sxs-lookup"><span data-stu-id="71653-138">Except for DISTINCTCOUNT, they don't affect aggregation behavior, and are primarily for readability.</span></span> <span data-ttu-id="71653-139">หากไม่มีรายการ GroupBy การรวมจะยังคงเกิดขึ้นตามความสัมพันธ์</span><span class="sxs-lookup"><span data-stu-id="71653-139">Without the GroupBy entries, the aggregations would still get hit, based on the relationships.</span></span> <span data-ttu-id="71653-140">ซึ่งจะแตกต่างจากตัวอย่าง [ตัวอย่างข้อมูลขนาดใหญ่](#aggregation-based-on-groupby-columns) ในภายหลังของบทความนี้ ซึ่งจะต้องมีรายการ GroupBy</span><span class="sxs-lookup"><span data-stu-id="71653-140">This is different from the [big data example](#aggregation-based-on-groupby-columns) later in this article, where the GroupBy entries are required.</span></span>

<span data-ttu-id="71653-141">หลังจากกำหนดการรวมข้อมูลที่คุณต้องการแล้ว ให้เลือก **นำไปใช้กับทั้งหมด**</span><span class="sxs-lookup"><span data-stu-id="71653-141">After defining the aggregations you want, select **Apply All**.</span></span> 

### <a name="validations"></a><span data-ttu-id="71653-142">การตรวจสอบความถูกต้อง</span><span class="sxs-lookup"><span data-stu-id="71653-142">Validations</span></span>

<span data-ttu-id="71653-143">กล่องโต้ตอบ **จัดการการรวมข้อมูล** จะบังคับใช้การตรวจสอบที่โดดเด่นดังต่อไปนี้:</span><span class="sxs-lookup"><span data-stu-id="71653-143">The **Manage aggregations** dialog enforces the following notable validations:</span></span>

- <span data-ttu-id="71653-144">**คอลัมน์รายละเอียด** ต้องมีข้อมูลประเภทเดียวกันกับ **คอลัมน์การวมข้อมูล** ยกเว้นฟังก์ชัน **การสรุป** ของการรวมแบบ Count และ Count table rows</span><span class="sxs-lookup"><span data-stu-id="71653-144">The **Detail Column** must have the same datatype as the **Aggregation Column**, except for the Count and Count table rows **Summarization** functions.</span></span> <span data-ttu-id="71653-145">การรวมแบบ Count และ Count table rows จะมีเฉพาะสำหรับคอลัมน์การรวมจำนวนเต็ม และไม่ต้องการหมวดหมู่ข้อมูลที่ตรงกัน</span><span class="sxs-lookup"><span data-stu-id="71653-145">Count and Count table rows are only available for integer aggregation columns, and don't require a matching datatype.</span></span>
- <span data-ttu-id="71653-146">ไม่อนุญาตให้มีการรวมแบบสายโซ่ที่ครอบคลุมสามตารางขึ้นไป</span><span class="sxs-lookup"><span data-stu-id="71653-146">Chained aggregations covering three or more tables aren't allowed.</span></span> <span data-ttu-id="71653-147">ตัวอย่างเช่น การรวมใน **Table A** ไม่สามารถอ้างอิงถึง **Table B** ที่มีการรวมที่อ้างอิงถึง **Table C** ได้</span><span class="sxs-lookup"><span data-stu-id="71653-147">For example, aggregations on **Table A** can't refer to a **Table B** that has aggregations referring to a **Table C**.</span></span>
- <span data-ttu-id="71653-148">ไม่อนุญาตสำหรับการรวมแบบซ้ำ ที่สองรายการใช้ฟังก์ชัน **การสรุป** เดียวกัน และอ้างถึง **ตารางรายละเอียด** และ **คอลัมน์รายละเอียด**</span><span class="sxs-lookup"><span data-stu-id="71653-148">Duplicate aggregations, where two entries use the same **Summarization** function and refer to the same **Detail Table** and **Detail Column**, aren't allowed.</span></span>
- <span data-ttu-id="71653-149">**ตารางรายละเอียด** ต้องใช้โหมดที่เก็บข้อมูล DirectQuery ไม่ใช่นำเข้า</span><span class="sxs-lookup"><span data-stu-id="71653-149">The **Detail Table** must use DirectQuery storage mode, not Import.</span></span>
- <span data-ttu-id="71653-150">การจัดกลุ่มตามคอลัมน์ Foreign Key ที่ใช้โดยความสัมพันธ์ที่ไม่ได้ใช้งานและการใช้ฟังก์ชัน USERELATIONSHIP สำหรับการรวมผู้เยี่ยมชมไม่ได้รับการสนับสนุน</span><span class="sxs-lookup"><span data-stu-id="71653-150">Grouping by a foreign key column used by an inactive relationship, and relying on the USERELATIONSHIP function for aggregation hits, isn't supported.</span></span>

<span data-ttu-id="71653-151">การตรวจสอบความถูกต้องส่วนใหญ่มีผลบังคับใช้โดยการปิดใช้งานค่าแบบเลื่อนลงและแสดงข้อความอธิบายในเคล็ดลับเครื่องมือ ดังแสดงในรูปต่อไปนี้</span><span class="sxs-lookup"><span data-stu-id="71653-151">Most of the validations are enforced by disabling dropdown values and showing explanatory text in the tooltip, as shown in the following image.</span></span>

![การตรวจสอบความถูกต้องที่แสดงโดยเคล็ดลับเครื่องมือ](media/desktop-aggregations/aggregations_08.jpg)

### <a name="aggregation-tables-are-hidden"></a><span data-ttu-id="71653-153">ตารางการรวมถูกซ่อนไว้</span><span class="sxs-lookup"><span data-stu-id="71653-153">Aggregation tables are hidden</span></span>

<span data-ttu-id="71653-154">ผู้ใช้ที่มีการเข้าถึงชุดข้อมูลแบบอ่านอย่างเดียวไม่สามารถคิวรีตารางการรวมได้</span><span class="sxs-lookup"><span data-stu-id="71653-154">Users with read-only access to the dataset can't query aggregation tables.</span></span> <span data-ttu-id="71653-155">ซึ่งเป็นการหลีกเลี่ยงข้อกังวลด้านความปลอดภัยเมื่อใช้กับ *การรักษาความปลอดภัยระดับแถว (RLS)*</span><span class="sxs-lookup"><span data-stu-id="71653-155">This avoids security concerns when used with *row-level security (RLS)*.</span></span> <span data-ttu-id="71653-156">ผู้บริโภคและคิวรีอ้างอิงถึงตารางรายละเอียด ไม่ใช่ตารางรวม และไม่จำเป็นต้องรู้เกี่ยวกับตารางรวม</span><span class="sxs-lookup"><span data-stu-id="71653-156">Consumers and queries refer to the detail table, not the aggregation table, and don't need to know about the aggregation table.</span></span>

<span data-ttu-id="71653-157">ด้วยเหตุนี้ ตารางรวมจะถูกซ่อนจากมุมมอง **รายงาน**</span><span class="sxs-lookup"><span data-stu-id="71653-157">For this reason, aggregation tables are hidden from **Report** view.</span></span> <span data-ttu-id="71653-158">ถ้าตารางยังไม่ได้ถูกซ่อน กล่องโต้ตอบ **จัดการการรวมข้อมูล** จะตั้งค่าเป็นซ่อนเมื่อคุณเลือก **นำไปใช้กับทั้งหมด**</span><span class="sxs-lookup"><span data-stu-id="71653-158">If the table isn't already hidden, the **Manage aggregations** dialog will set it to hidden when you select **Apply all**.</span></span>

### <a name="storage-modes"></a><span data-ttu-id="71653-159">โหมดที่เก็บข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-159">Storage modes</span></span>
<span data-ttu-id="71653-160">คุณลักษณะการรวมข้อมูลโต้ตอบกับโหมดที่เก็บข้อมูลระดับตาราง</span><span class="sxs-lookup"><span data-stu-id="71653-160">The aggregation feature interacts with table-level storage modes.</span></span> <span data-ttu-id="71653-161">ตาราง Power BI สามารถใช้โหมดที่เก็บข้อมูล *DirectQuery*, *Import* หรือ *Dual*</span><span class="sxs-lookup"><span data-stu-id="71653-161">Power BI tables can use *DirectQuery*, *Import*, or *Dual* storage modes.</span></span> <span data-ttu-id="71653-162">DirectQuery คิวรีแบ็กเอนด์โดยตรง ในขณะที่นำเข้าแคชข้อมูลในหน่วยความจำและส่งคิวรีไปยังข้อมูลที่เก็บไว้ในแคช</span><span class="sxs-lookup"><span data-stu-id="71653-162">DirectQuery queries the backend directly, while Import caches data in memory and sends queries to the cached data.</span></span> <span data-ttu-id="71653-163">การนำเข้า Power BI และแหล่งข้อมูล DirectQuery ที่ไม่ใช่แบบหลายมิติทั้งหมดสามารถทำงานร่วมกับการรวมข้อมูลได้</span><span class="sxs-lookup"><span data-stu-id="71653-163">All Power BI Import and non-multidimensional DirectQuery data sources can work with aggregations.</span></span> 

<span data-ttu-id="71653-164">เมื่อต้องการตั้งค่าโหมดที่เก็บข้อมูลของตารางรวมเป็นนำเข้าเพื่อเพิ่มความเร็วคิวรี ให้เลือกตารางรวมในมุมมอง **แบบจำลอง** Power BI Desktop</span><span class="sxs-lookup"><span data-stu-id="71653-164">To set the storage mode of an aggregated table to Import to speed up queries, select the aggregated table in Power BI Desktop **Model** view.</span></span> <span data-ttu-id="71653-165">ในบานหน้าต่าง **คุณสมบัติ** ให้ขยาย **ขั้นสูง** ดึงเมนูการเลือกลงภายใต้ **โหมดที่เก็บข้อมูล** และเลือก **นำเข้า**</span><span class="sxs-lookup"><span data-stu-id="71653-165">In the **Properties** pane, expand **Advanced**, drop down the selection under **Storage mode**, and select **Import**.</span></span> <span data-ttu-id="71653-166">โปรดทราบว่าการดำเนินการนี้จะไม่สามารถย้อนกลับได้</span><span class="sxs-lookup"><span data-stu-id="71653-166">Note that this action is irreversible.</span></span> 

![ตั้งค่าโหมดที่เก็บข้อมูล](media/desktop-aggregations/aggregations-04.png)

<span data-ttu-id="71653-168">สำหรับข้อมูลเพิ่มเติมเกี่ยวกับโหมดที่เก็บข้อมูลของตาราง โปรดดู [จัดการโหมดที่เก็บข้อมูลใน Power BI Desktop](desktop-storage-mode.md)</span><span class="sxs-lookup"><span data-stu-id="71653-168">For more information about table storage modes, see [Manage storage mode in Power BI Desktop](desktop-storage-mode.md).</span></span>

### <a name="rls-for-aggregations"></a><span data-ttu-id="71653-169">RLS สำหรับการรวม</span><span class="sxs-lookup"><span data-stu-id="71653-169">RLS for aggregations</span></span>

<span data-ttu-id="71653-170">เพื่อให้การรวมทำงานได้อย่างถูกต้อง RLS ควรกรองทั้งตารางการรวมและตารางรายละเอียด</span><span class="sxs-lookup"><span data-stu-id="71653-170">To work correctly for aggregations, RLS expressions should filter both the aggregation table and the detail table.</span></span> 

<span data-ttu-id="71653-171">ในตัวอย่างต่อไปนี้ นิพจน์ RLS บนตาราง **Geography** ใช้สำหรับการรวมเนื่องจากภูมิศาสตร์อยู่ทางด้านการกรองของความสัมพันธ์กับทั้งตาราง **Sales** และตาราง **Sales Agg**</span><span class="sxs-lookup"><span data-stu-id="71653-171">In the following example, the RLS expression on the **Geography** table works for aggregations, because Geography is on the filtering side of relationships to both the **Sales** table and the **Sales Agg** table.</span></span> <span data-ttu-id="71653-172">ทั้งคิวรีที่ใช้งานและไม่ใช้งานตารางการรวมจะปรับใช้ RLS ได้สำเร็จ</span><span class="sxs-lookup"><span data-stu-id="71653-172">Queries that hit the aggregation table and those that don't will both have RLS successfully applied.</span></span>

![RLS สำหรับการรวมที่สำเร็จ](media/desktop-aggregations/manage-roles.png)

<span data-ttu-id="71653-174">นิพจน์ RLS บนตาราง **Product** จะกรองเฉพาะตาราง **Sales** รายละเอียด ไม่ใช่ตาราง **Sales Agg** รวม</span><span class="sxs-lookup"><span data-stu-id="71653-174">An RLS expression on the **Product** table filters only the detail **Sales** table, not the aggregated **Sales Agg** table.</span></span> <span data-ttu-id="71653-175">เนื่องจากตารางการรวมเป็นการแสดงข้อมูลในตารางรายละเอียด ดังนั้นจึงไม่ปลอดภัยที่จะตอบคิวรีจากตารางการรวมถ้าไม่สามารถใช้ตัวกรอง RLS ได้</span><span class="sxs-lookup"><span data-stu-id="71653-175">Since the aggregation table is another representation of the data in the detail table, it would be insecure to answer queries from the aggregation table if the RLS filter can't be applied.</span></span> <span data-ttu-id="71653-176">ไม่แนะนำให้กรองเฉพาะตารางรายละเอียด เนื่องจากคิวรีของผู้ใช้จากบทบาทนี้จะไม่ได้รับประโยชน์จากการรวมข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-176">Filtering only the detail table isn't recommended, because user queries from this role won't benefit from aggregation hits.</span></span> 

<span data-ttu-id="71653-177">นิพจน์ RLS ที่กรองเฉพาะตารางการรวม **Sales Agg** และไม่อนุญาตที่ไม่ใช่ตารางรายละเอียด **Sales**</span><span class="sxs-lookup"><span data-stu-id="71653-177">An RLS expression that filters only the **Sales Agg** aggregation table and not the **Sales** detail table isn't allowed.</span></span>

![ไม่อนุญาต RLS บนตารางการรวมเท่านั้น](media/desktop-aggregations/filter-agg-error.jpg)

<span data-ttu-id="71653-179">สำหรับ[การรวมข้อมูลที่อ้างอิงตามคอลัมน์ GroupBy](#aggregation-based-on-groupby-columns) นิพจน์ RLS ที่นำไปใช้กับตารางรายละเอียดสามารถใช้เพื่อกรองตารางการรวมได้ เนื่องจากตารางรายละเอียดครอบคลุมคอลัมน์ GroupBy ทั้งหมดในตารางการรวม</span><span class="sxs-lookup"><span data-stu-id="71653-179">For [aggregations based on GroupBy columns](#aggregation-based-on-groupby-columns), an RLS expression applied to the detail table can be used to filter the aggregation table, because all the GroupBy columns in the aggregation table are covered by the detail table.</span></span> <span data-ttu-id="71653-180">ในทางกลับกัน ตัวกรอง RLS บนตารางการรวมไม่สามารถนำไปใช้กับตารางรายละเอียด ดังนั้นจึงไม่ได้รับอนุญาต</span><span class="sxs-lookup"><span data-stu-id="71653-180">On the other hand, an RLS filter on the aggregation table can't be applied to the detail table, so is disallowed.</span></span>

## <a name="aggregation-based-on-relationships"></a><span data-ttu-id="71653-181">การรวมอิงตามความสัมพันธ์</span><span class="sxs-lookup"><span data-stu-id="71653-181">Aggregation based on relationships</span></span>

<span data-ttu-id="71653-182">โดยทั่วไปแบบจำลองมิติใช้ *การรวมอิงตามความสัมพันธ์*</span><span class="sxs-lookup"><span data-stu-id="71653-182">Dimensional models typically use *aggregations based on relationships*.</span></span> <span data-ttu-id="71653-183">ชุดข้อมูล Power BI จากคลังข้อมูลและตลาดข้อมูลคล้ายคลึงกับแผนผังแบบผลึกหิมะ/แบบดาวที่มีความสัมพันธ์ระหว่างตารางมิติและตารางหลัก</span><span class="sxs-lookup"><span data-stu-id="71653-183">Power BI datasets from data warehouses and data marts resemble star/snowflake schemas, with relationships between dimension tables and fact tables.</span></span>

<span data-ttu-id="71653-184">ในแบบจำลองต่อไปนี้จากแหล่งข้อมูลเดียว ตารางกำลังใช้โหมดที่เก็บข้อมูล DirectQuery</span><span class="sxs-lookup"><span data-stu-id="71653-184">In the following model from a single data source, the tables are using DirectQuery storage mode.</span></span> <span data-ttu-id="71653-185">ตารางหลัก **ยอดขาย** มีหลายพันล้านแถว</span><span class="sxs-lookup"><span data-stu-id="71653-185">The **Sales** fact table contains billions of rows.</span></span> <span data-ttu-id="71653-186">การตั้งค่าโหมดพื้นที่เก็บข้อมูล **ยอดขาย** เป็นนำเข้า สำหรับการแคชจะใช้หน่วยความจำและค่าใช้จ่ายในการจัดการที่มาก</span><span class="sxs-lookup"><span data-stu-id="71653-186">Setting the storage mode of **Sales** to Import for caching would consume considerable memory and management overhead.</span></span>

![ตารางรายละเอียดในแบบจำลอง](media/desktop-aggregations/aggregations_02.jpg)

<span data-ttu-id="71653-188">แต่เราจะสร้างตารางการรวม **Sales Agg**</span><span class="sxs-lookup"><span data-stu-id="71653-188">Instead, create the **Sales Agg** aggregation table.</span></span> <span data-ttu-id="71653-189">ในตาราง **Sales Agg** จำนวนแถวควรเท่ากับยอดรวม **SalesAmount (ปริมาณการขาย)** ที่จัดกลุ่มตาม **CustomerKey(คีย์ข้อมูลลูกค้า)** , **DateKey(คีย์ข้อมูลวันที่)** และ **ProductSubcategoryKey(คีย์ข้อมูลหมวดหมู่ย่อยของผลิตภัณฑ์)**</span><span class="sxs-lookup"><span data-stu-id="71653-189">In the **Sales Agg** table, the number of rows equals the sum of **SalesAmount** grouped by **CustomerKey**, **DateKey**, and **ProductSubcategoryKey**.</span></span> <span data-ttu-id="71653-190">ตาราง **Sales Agg** อยู่ใน ระดับการปิดกั้น (Granularity) ที่สูงกว่า **Sales** ดังนั้นแทนที่จะเป็นพันล้าน ตารางอาจมีหลายล้านแถวซึ่งง่ายต่อการจัดการ</span><span class="sxs-lookup"><span data-stu-id="71653-190">The **Sales Agg** table is at a higher granularity than **Sales**, so instead of billions, it might contain millions of rows, which are much easier to manage.</span></span>

<span data-ttu-id="71653-191">หากตารางมิติข้อมูลต่อไปนี้ถูกใช้บ่อยที่สุดสำหรับคิวรีที่มีมูลค่าธุรกิจสูง พวกเขาสามารถกรอง **Sales Agg** โดยใช้ความสัมพันธ์แบบ *หนึ่งต่อกลุ่ม* หรือ *กลุ่มต่อหนึ่ง*</span><span class="sxs-lookup"><span data-stu-id="71653-191">If the following dimension tables are the most commonly used for the queries with high business value, they can filter **Sales Agg**, using *one-to-many* or *many-to-one* relationships.</span></span>

- <span data-ttu-id="71653-192">ภูมิศาสตร์</span><span class="sxs-lookup"><span data-stu-id="71653-192">Geography</span></span>
- <span data-ttu-id="71653-193">ลูกค้า</span><span class="sxs-lookup"><span data-stu-id="71653-193">Customer</span></span>
- <span data-ttu-id="71653-194">วัน</span><span class="sxs-lookup"><span data-stu-id="71653-194">Date</span></span>
- <span data-ttu-id="71653-195">หมวดสินค้าย่อยของผลิตภัณฑ์</span><span class="sxs-lookup"><span data-stu-id="71653-195">Product Subcategory</span></span>
- <span data-ttu-id="71653-196">หมวดสินค้าของผลิตภัณฑ์</span><span class="sxs-lookup"><span data-stu-id="71653-196">Product Category</span></span>

<span data-ttu-id="71653-197">รูปภาพต่อไปนี้แสดงแบบจำลองนี้</span><span class="sxs-lookup"><span data-stu-id="71653-197">The following image shows this model.</span></span>

![ตารางการรวมในแบบจำลอง](media/desktop-aggregations/aggregations_03.jpg)

<span data-ttu-id="71653-199">ตารางต่อไปนี้แสดงการรวมสำหรับตาราง **Sales Agg**</span><span class="sxs-lookup"><span data-stu-id="71653-199">The following table shows the aggregations for the **Sales Agg** table.</span></span>

![การรวมสำหรับตาราง Sales Agg](media/desktop-aggregations/aggregations-table_01.jpg)

> [!NOTE]
> <span data-ttu-id="71653-201">ตาราง **Sales Agg** เหมือนกับตารางอื่นใดก็ตาม ดังนั้นจึงมีความยืดหยุ่นในการโหลดด้วยวิธีการต่างๆ</span><span class="sxs-lookup"><span data-stu-id="71653-201">The **Sales Agg** table, like any table, has the flexibility of being loaded in a variety of ways.</span></span> <span data-ttu-id="71653-202">การรวมสามารถทำได้ในฐานข้อมูลต้นทางโดยใช้กระบวนการ ETL/ELT หรือโดย [นิพจน์ M](/powerquery-m/power-query-m-function-reference) สำหรับตาราง</span><span class="sxs-lookup"><span data-stu-id="71653-202">The aggregation can be performed in the source database using ETL/ELT processes, or by the [M expression](/powerquery-m/power-query-m-function-reference) for the table.</span></span> <span data-ttu-id="71653-203">ตารางรวมสามารถใช้โหมดพื้นที่เก็บข้อมูลการนำเข้าที่มีหรือไม่มี [การรีเฟรชแบบเพิ่มหน่วยในบริการ Power BI Premium](../admin/service-premium-incremental-refresh.md) หรือสามารถใช้ DirectQuery และเพิ่มประสิทธิภาพสำหรับการคิวรีอย่างรวดเร็วโดยใช้ [ดัชนี columnstore](/sql/relational-databases/indexes/columnstore-indexes-overview)</span><span class="sxs-lookup"><span data-stu-id="71653-203">The aggregated table can use Import storage mode, with or without [incremental refresh in Power BI Premium](../admin/service-premium-incremental-refresh.md), or it can use DirectQuery and be optimized for fast queries using [columnstore indexes](/sql/relational-databases/indexes/columnstore-indexes-overview).</span></span> <span data-ttu-id="71653-204">ความยืดหยุ่นนี้จะช่วยให้สถาปัตยกรรมที่สมดุลสามารถกระจายโหลดคิวรีเพื่อหลีกเลี่ยงปัญหาคอขวดได้</span><span class="sxs-lookup"><span data-stu-id="71653-204">This flexibility enables balanced architectures that can spread query load to avoid bottlenecks.</span></span>

<span data-ttu-id="71653-205">การเปลี่ยนแปลงโหมดที่เก็บข้อมูลของตารางการ **Sales Agg** รวมไปเป็น **นำเข้า** เปิดกล่องโต้ตอบที่บอกว่าตารางมิติที่เกี่ยวข้องสามารถตั้งค่าเป็นโหมดที่เก็บข้อมูล *Dual*</span><span class="sxs-lookup"><span data-stu-id="71653-205">Changing the storage mode of the aggregated **Sales Agg** table to **Import** opens a dialog box saying that the related dimension tables can be set to storage mode *Dual*.</span></span> 

![กล่องโต้ตอบโหมดที่เก็บข้อมูล](media/desktop-aggregations/aggregations_05.jpg)

<span data-ttu-id="71653-207">การตั้งค่าตารางมิติข้อมูลที่เกี่ยวข้องให้เป็น Dual ช่วยให้สามารถทำหน้าที่เป็นการนำเข้าหรือ DirectQuery ขึ้นอยู่กับคิวรีย่อย</span><span class="sxs-lookup"><span data-stu-id="71653-207">Setting the related dimension tables to Dual lets them act as either Import or DirectQuery, depending on the subquery.</span></span> <span data-ttu-id="71653-208">ในตัวอย่าง:</span><span class="sxs-lookup"><span data-stu-id="71653-208">In the example:</span></span>

- <span data-ttu-id="71653-209">คิวรีที่รวมเมตริกจากตาราง **Sales Agg** ด้วยโหมดนำเข้า และจัดกลุ่มตามแอตทริบิวต์จากตารางคู่ที่เกี่ยวข้องสามารถได้รับคืนจากแคชในหน่วยความจำ</span><span class="sxs-lookup"><span data-stu-id="71653-209">Queries that aggregate metrics from the Import-mode **Sales Agg** table, and group by attribute(s) from the related Dual tables, can be returned from the in-memory cache.</span></span>
- <span data-ttu-id="71653-210">คิวรีที่รวมเมตริกจากตาราง **Sales** ด้วยโหมด DirectQuery และจัดกลุ่มตามแอตทริบิวต์จากตารางคู่ที่เกี่ยวข้องสามารถได้รับคืนจากโหมด DirectQuery</span><span class="sxs-lookup"><span data-stu-id="71653-210">Queries that aggregate metrics from the DirectQuery **Sales** table, and group by attribute(s) from the related Dual tables, can be returned in DirectQuery mode.</span></span> <span data-ttu-id="71653-211">ตรรกะคิวรีที่ประกอบด้วยการดำเนินการ GroupBy จะถูกส่งลงไปยังฐานข้อมูลต้นทาง</span><span class="sxs-lookup"><span data-stu-id="71653-211">The query logic, including the GroupBy operation, is passed down to the source database.</span></span>

<span data-ttu-id="71653-212">สำหรับข้อมูลเพิ่มเติมเกี่ยวกับโหมดที่เก็บข้อมูล Dual โปรดดู [จัดการโหมดที่เก็บข้อมูลใน Power BI Desktop](desktop-storage-mode.md)</span><span class="sxs-lookup"><span data-stu-id="71653-212">For more information about Dual storage mode, see [Manage storage mode in Power BI Desktop](desktop-storage-mode.md).</span></span>

### <a name="regular-vs-limited-relationships"></a><span data-ttu-id="71653-213">ความสัมพันธ์แบบปกติเทียบกับแบบจำกัด</span><span class="sxs-lookup"><span data-stu-id="71653-213">Regular vs. limited relationships</span></span>

<span data-ttu-id="71653-214">การรวมอิงที่ตามความสัมพันธ์จำเป็นต้องมีความสัมพันธ์แบบปกติ</span><span class="sxs-lookup"><span data-stu-id="71653-214">Aggregation hits based on relationships require regular relationships.</span></span>

<span data-ttu-id="71653-215">ความสัมพันธ์แบบปกติประกอบด้วยการผสมรวมโหมดที่เก็บข้อมูลดังต่อไปนี้ ที่ซึ่งตารางทั้งสองมาจากแหล่งข้อมูลเดียว:</span><span class="sxs-lookup"><span data-stu-id="71653-215">Regular relationships include the following storage mode combinations, where both tables are from a single source:</span></span>

| <span data-ttu-id="71653-216">ตารางที่ด้าน *กลุ่ม*</span><span class="sxs-lookup"><span data-stu-id="71653-216">Table on the *many* sides</span></span> | <span data-ttu-id="71653-217">ตาราง *1* ด้าน</span><span class="sxs-lookup"><span data-stu-id="71653-217">Table on the *1* side</span></span> |
| ------------- |----------------------| 
| <span data-ttu-id="71653-218">คู่</span><span class="sxs-lookup"><span data-stu-id="71653-218">Dual</span></span>          | <span data-ttu-id="71653-219">คู่</span><span class="sxs-lookup"><span data-stu-id="71653-219">Dual</span></span>                 | 
| <span data-ttu-id="71653-220">นำเข้า</span><span class="sxs-lookup"><span data-stu-id="71653-220">Import</span></span>        | <span data-ttu-id="71653-221">นำเข้า หรือ คู่</span><span class="sxs-lookup"><span data-stu-id="71653-221">Import or Dual</span></span>       | 
| <span data-ttu-id="71653-222">DirectQuery</span><span class="sxs-lookup"><span data-stu-id="71653-222">DirectQuery</span></span>   | <span data-ttu-id="71653-223">DirectQuery หรือ คู่</span><span class="sxs-lookup"><span data-stu-id="71653-223">DirectQuery or Dual</span></span>  | 

<span data-ttu-id="71653-224">กรณีเดียวที่ถือว่าความสัมพันธ์ *ข้ามแหล่งข้อมูล* เป็นแบบปกติ คือตารางทั้งสองถูกตั้งค่าเป็นโหมดนำเข้า</span><span class="sxs-lookup"><span data-stu-id="71653-224">The only case where a *cross-source* relationship is considered regular is if both tables are set to Import.</span></span> <span data-ttu-id="71653-225">ความสัมพันธ์แบบกลุ่มต่อกลุ่มนั้นถือว่าเป็นแบบจำกัดเสมอ</span><span class="sxs-lookup"><span data-stu-id="71653-225">Many-to-many relationships are always considered limited.</span></span>

<span data-ttu-id="71653-226">สำหรับการรวมแบบ *ข้ามแหล่งข้อมูล* ที่ไม่อิงตามความสัมพันธ์ โปรดดู [การรวมที่อิงตามคอลัมน์ GroupBy](#aggregation-based-on-groupby-columns)</span><span class="sxs-lookup"><span data-stu-id="71653-226">For *cross-source* aggregation hits that don't depend on relationships, see [Aggregations based on GroupBy columns](#aggregation-based-on-groupby-columns).</span></span> 

### <a name="relationship-based-aggregation-query-examples"></a><span data-ttu-id="71653-227">ตัวอย่างคิวรีการรวมอิงตามความสัมพันธ์</span><span class="sxs-lookup"><span data-stu-id="71653-227">Relationship-based aggregation query examples</span></span>

<span data-ttu-id="71653-228">คิวรี่ต่อไปนี้จะทำให้เกิดการรวม เนื่องจากคอลัมน์ในตาราง **วันที่** มีความละเอียดที่สามารถรวมได้</span><span class="sxs-lookup"><span data-stu-id="71653-228">The following query hits the aggregation, because columns in the **Date** table are at the granularity that can hit the aggregation.</span></span> <span data-ttu-id="71653-229">คอลัมน์ **SalesAmount** ใช้การรวมข้อมูลแบบ **Sum**</span><span class="sxs-lookup"><span data-stu-id="71653-229">The **SalesAmount** column uses the **Sum** aggregation.</span></span>

![คิวรีการรวมอิงตามความสัมพันธ์ที่สำเร็จ](media/desktop-aggregations/aggregations-code_02.jpg)

<span data-ttu-id="71653-231">คิวรี่ต่อไปนี้จะไม่เกิดการรวม</span><span class="sxs-lookup"><span data-stu-id="71653-231">The following query doesn't hit the aggregation.</span></span> <span data-ttu-id="71653-232">แม้จะร้องขอยอดรวมของ **SalesAmount** แต่คิวรีก็ดำเนินการ GroupBy บนคอลัมน์ในตาราง **Product** ซึ่งไม่มีระดับการปิดกั้นที่สามารถรวมข้อมูลได้</span><span class="sxs-lookup"><span data-stu-id="71653-232">Despite requesting the sum of **SalesAmount**, the query is performing a GroupBy operation on a column in the **Product** table, which isn't at the granularity that can hit the aggregation.</span></span> <span data-ttu-id="71653-233">ถ้าคุณสังเกตความสัมพันธ์ในแบบจำลอง หมวดหมู่ย่อยของผลิตภัณฑ์สามารถมีแถวในคอลัมน์ **Product** ได้หลายแถว</span><span class="sxs-lookup"><span data-stu-id="71653-233">If you observe the relationships in the model, a product subcategory can have multiple **Product** rows.</span></span> <span data-ttu-id="71653-234">คิวรีจะไม่สามารถระบุได้ว่าจะรวมผลิตภัณฑ์ใดเข้าด้วยกัน</span><span class="sxs-lookup"><span data-stu-id="71653-234">The query wouldn't be able to determine which product to aggregate to.</span></span> <span data-ttu-id="71653-235">ในกรณีนี้คิวรี่จะย้อนกลับไปยัง DirectQuery และส่งคิวรี่ SQL ไปยังแหล่งข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-235">In this case, the query reverts to DirectQuery and submits a SQL query to the data source.</span></span>

![คิวรีที่ไม่สามารถใช้การรวมได้](media/desktop-aggregations/aggregations-code_03.jpg)

<span data-ttu-id="71653-237">การรวมไม่ใช่แค่การคำนวณแบบง่ายที่สร้างผลรวมแบบตรงไปตรงมาเท่านั้น</span><span class="sxs-lookup"><span data-stu-id="71653-237">Aggregations aren't just for simple calculations that perform a straightforward sum.</span></span> <span data-ttu-id="71653-238">แต่ยังได้รับประโยชน์จากการคำนวณที่ซับซ้อนอีกด้วย</span><span class="sxs-lookup"><span data-stu-id="71653-238">Complex calculations can also benefit.</span></span> <span data-ttu-id="71653-239">ตามแนวคิดแล้ว การคำนวณที่ซับซ้อนจะแบ่งย่อยเป็นคิวรีย่อยสำหรับแต่ละ SUM, MIN, MAX และ COUNT และแต่ละคิวรีย่อยจะได้รับการประเมินเพื่อกำหนดว่าจะสามารถดำเนินการรวมได้หรือไม่</span><span class="sxs-lookup"><span data-stu-id="71653-239">Conceptually, a complex calculation is broken down into subqueries for each SUM, MIN, MAX, and COUNT, and each subquery is evaluated to determine if it can hit the aggregation.</span></span> <span data-ttu-id="71653-240">ตรรกะนี้ไม่ถือเป็นจริงในทุกกรณีเนื่องจากการเพิ่มประสิทธิภาพแผนคิวรี่ แต่โดยทั่วไปควรใช้ตรรกะนี้</span><span class="sxs-lookup"><span data-stu-id="71653-240">This logic doesn't hold true in all cases due to query-plan optimization, but in general it should apply.</span></span> <span data-ttu-id="71653-241">ตัวอย่างต่อไปนี้จะทำให้เกิดการรวม:</span><span class="sxs-lookup"><span data-stu-id="71653-241">The following example hits the aggregation:</span></span>

![คิวรีการรวมที่ซับซ้อน](media/desktop-aggregations/aggregations-code_04.jpg)

<span data-ttu-id="71653-243">ฟังก์ชั่น COUNTROWS จะได้ประโยชน์จากการรวม</span><span class="sxs-lookup"><span data-stu-id="71653-243">The COUNTROWS function can benefit from aggregations.</span></span> <span data-ttu-id="71653-244">คิวรีต่อไปนี้จะทำให้เกิดการรวมเนื่องจากมีการรวมแบบ **Count table rows** ที่กำหนดไว้สำหรับตาราง **Sales**</span><span class="sxs-lookup"><span data-stu-id="71653-244">The following query hits the aggregation because there is a **Count table rows** aggregation defined for the **Sales** table.</span></span>

![คิวรีการรวม COUNTROWS](media/desktop-aggregations/aggregations-code_05.jpg)

<span data-ttu-id="71653-246">ฟังก์ชั่น AVERAGE จะได้ประโยชน์จากการรวมข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-246">The AVERAGE function can benefit from aggregations.</span></span> <span data-ttu-id="71653-247">คิวรี่ต่อไปนี้จะทำให้เกิดการรวมเนื่องจาก AVERAGE จะถูกห่อหุ้มด้วย SUM ภายในซึ่งถูกหารด้วย COUNT</span><span class="sxs-lookup"><span data-stu-id="71653-247">The following query hits the aggregation because AVERAGE internally gets folded to a SUM divided by a COUNT.</span></span> <span data-ttu-id="71653-248">เนื่องจากคอลัมน์ **UnitPrice** มีการรวมข้อมูลที่กำหนดไว้สำหรับทั้ง SUM และ COUNT ดังนั้นการรวมจึงเกิดขึ้น</span><span class="sxs-lookup"><span data-stu-id="71653-248">Since the **UnitPrice** column has aggregations defined for both SUM and COUNT, the aggregation is hit.</span></span>

![คิวรีการรวม AVERAGE](media/desktop-aggregations/aggregations-code_06.jpg)

<span data-ttu-id="71653-250">ในบางกรณี ฟังก์ชั่น DISTINCTCOUNT จะได้ประโยชน์จากการรวม</span><span class="sxs-lookup"><span data-stu-id="71653-250">In some cases, the DISTINCTCOUNT function can benefit from aggregations.</span></span> <span data-ttu-id="71653-251">คิวรี่ต่อไปนี้จะเกิดการรวมเนื่องจากมีรายการ GroupBy สำหรับ **CustomerKey** ซึ่งจะรักษาความแตกต่างของ **CustomerKey** ในตารางรวม</span><span class="sxs-lookup"><span data-stu-id="71653-251">The following query hits the aggregation because there is a GroupBy entry for **CustomerKey**, which maintains the distinctness of **CustomerKey** in the aggregation table.</span></span> <span data-ttu-id="71653-252">เทคนิคนี้อาจยังอยู่ภายใต้เกณฑ์ประสิทธิภาพที่มีค่ามากกว่าสองถึงห้าล้านค่าที่ส่งผลต่อประสิทธิภาพการคิวรี</span><span class="sxs-lookup"><span data-stu-id="71653-252">This technique might still hit the performance threshold where more than two to five million distinct values can affect query performance.</span></span> <span data-ttu-id="71653-253">อย่างไรก็ตาม อาจเป็นประโยชน์ในสถานการณ์ที่มีตารางนับพันล้านแถว แต่มีค่าที่แตกต่างกันสองถึงห้าล้านค่าในคอลัมน์</span><span class="sxs-lookup"><span data-stu-id="71653-253">However, it can be useful in scenarios where there are billions of rows in the detail table, but two to five million distinct values in the column.</span></span> <span data-ttu-id="71653-254">ในกรณีนี้ DISTINCTCOUNT สามารถทำได้เร็วกว่าการสแกนตารางที่มีแถวหลายพันล้านแถว แม้ว่าจะถูกแคชไว้ในหน่วยความจำก็ตาม</span><span class="sxs-lookup"><span data-stu-id="71653-254">In this case, the DISTINCTCOUNT can perform faster than scanning the table with billions of rows, even if it were cached into memory.</span></span>

![คิวรีการรวม DISTINCTCOUNT](media/desktop-aggregations/aggregations-code_07.jpg)

<span data-ttu-id="71653-256">ฟังก์ชันตัวแสดงเวลาของ DAX เป็นการตระหนักรู้การรวม</span><span class="sxs-lookup"><span data-stu-id="71653-256">DAX time-intelligence functions are aggregation aware.</span></span> <span data-ttu-id="71653-257">คิวรี่ต่อไปนี้จะทำให้เกิดการรวม เนื่องจากฟังก์ชัน DATESYTD สร้างตารางของค่า **CalendarDay** และตารางการรวมจะอยู่ในระดับการปิดกั้นที่ครอบคลุมสำหรับคอลัมน์ group-by ในตาราง **Date**</span><span class="sxs-lookup"><span data-stu-id="71653-257">The following query hits the aggregation because the DATESYTD function generates a table of **CalendarDay** values, and the aggregation table is at a granularity that is covered for group-by columns in the **Date** table.</span></span> <span data-ttu-id="71653-258">นี่คือตัวอย่างของตัวกรองค่าตารางไปยังฟังก์ชัน CALCULATE ซึ่งสามารถทำงานกับการรวมได้</span><span class="sxs-lookup"><span data-stu-id="71653-258">This is an example of a table-valued filter to the CALCULATE function, which can work with aggregations.</span></span>

![คิวรีการรวม SUMMARIZECOLUMNS](media/desktop-aggregations/aggregations-code-07b.jpg)

## <a name="aggregation-based-on-groupby-columns"></a><span data-ttu-id="71653-260">การรวมที่อิงตามคอลัมน์ GroupBy</span><span class="sxs-lookup"><span data-stu-id="71653-260">Aggregation based on GroupBy columns</span></span> 

<span data-ttu-id="71653-261">แบบจำลองข้อมูลขนาดใหญ่ที่ใช้ Hadoop มีลักษณะที่แตกต่างจากแบบจำลองมิติ</span><span class="sxs-lookup"><span data-stu-id="71653-261">Hadoop-based big data models have different characteristics than dimensional models.</span></span> <span data-ttu-id="71653-262">เพื่อหลีกเลี่ยงการต่อรวมระหว่างตารางขนาดใหญ่ แบบจำลองข้อมูลขนาดใหญ่มักจะไม่ใช้ความสัมพันธ์ แต่จะดีนอร์มอลไลแอตทริบิวต์มิติไปเป็นตารางเท็จจริง</span><span class="sxs-lookup"><span data-stu-id="71653-262">To avoid joins between large tables, big data models often don't use relationships, but denormalize dimension attributes to fact tables.</span></span> <span data-ttu-id="71653-263">คุณสามารถปลดล็อกแบบจำลองข้อมูลขนาดใหญ่ดังกล่าวสำหรับการวิเคราะห์แบบโต้ตอบโดยใช้ *การรวมที่อิงตามคอลัมน์ GroupBy*</span><span class="sxs-lookup"><span data-stu-id="71653-263">You can unlock such big data models for interactive analysis by using *aggregations based on GroupBy columns*.</span></span>

<span data-ttu-id="71653-264">ตารางต่อไปนี้ประกอบด้วยคอลัมน์ตัวเลขที่ **การเคลื่อนไหว** ที่ถูกรวม</span><span class="sxs-lookup"><span data-stu-id="71653-264">The following table contains the **Movement** numeric column to be aggregated.</span></span> <span data-ttu-id="71653-265">คอลัมน์อื่นทั้งหมดเป็นแอตทริบิวต์ในการจัดกลุ่มตาม (group by)</span><span class="sxs-lookup"><span data-stu-id="71653-265">All the other columns are attributes to group by.</span></span> <span data-ttu-id="71653-266">ตารางประกอบด้วยข้อมูล IoT และแถวจำนวนมาก</span><span class="sxs-lookup"><span data-stu-id="71653-266">The table contains IoT data and a massive number of rows.</span></span> <span data-ttu-id="71653-267">โหมดพื้นที่เก็บข้อมูลคือ DirectQuery</span><span class="sxs-lookup"><span data-stu-id="71653-267">The storage mode is DirectQuery.</span></span> <span data-ttu-id="71653-268">คิวรี่ในแหล่งข้อมูลที่รวมทั่วทั้งชุดข้อมูลทั้งหมดทำงานช้าเนื่องจากมีปริมาณข้อมูลเต็มที่</span><span class="sxs-lookup"><span data-stu-id="71653-268">Queries on the data source that aggregate across the whole dataset are slow because of the sheer volume.</span></span> 

![ตาราง IoT](media/desktop-aggregations/aggregations_09.jpg)

<span data-ttu-id="71653-270">เพื่อเปิดใช้งานการวิเคราะห์แบบโต้ตอบกับชุดข้อมูลนี้ คุณสามารถเพิ่มตารางการรวมที่จัดกลุ่มตามแอตทริบิวต์ส่วนใหญ่ แต่ยกเว้นแอตทริบิวต์คาร์ดินอลลิตี้ (cardinality) ที่มีค่าสูง เช่น ลองจิจูดและละติจูด</span><span class="sxs-lookup"><span data-stu-id="71653-270">To enable interactive analysis on this dataset, you can add an aggregation table that groups by most of the attributes, but excludes the high-cardinality attributes like longitude and latitude.</span></span> <span data-ttu-id="71653-271">ซึ่งช่วยลดจำนวนแถวได้อย่างมากและมีขนาดเล็กพอที่จะพอดีกับแคชในหน่วยความจำได้อย่างสบาย</span><span class="sxs-lookup"><span data-stu-id="71653-271">This dramatically reduces the number of rows, and is small enough to comfortably fit into an in-memory cache.</span></span> 

![ตาราง Driver Activity Agg table](media/desktop-aggregations/aggregations_10.jpg)

<span data-ttu-id="71653-273">คุณกำหนดการแมปการรวมสำหรับตาราง **Driver Activity Agg** ในกล่องโต้ตอบ **จัดการการรวมข้อมูล**</span><span class="sxs-lookup"><span data-stu-id="71653-273">You define the aggregation mappings for the **Driver Activity Agg** table in the **Manage aggregations** dialog.</span></span> 

![กล่องโต้ตอบManage aggregationสำหรับตาราง Driver Activity Agg](media/desktop-aggregations/aggregations_11.jpg)

<span data-ttu-id="71653-275">ในการรวมที่อิงตามคอลัมน์ GroupBy รายการ **GroupBy** จะไม่เป็นทางเลือก</span><span class="sxs-lookup"><span data-stu-id="71653-275">In aggregations based on GroupBy columns, the **GroupBy** entries aren't optional.</span></span> <span data-ttu-id="71653-276">หากไม่มีรายการดังกล่าว การรวมข้อมูลจะไม่เกิดขึ้น</span><span class="sxs-lookup"><span data-stu-id="71653-276">Without them, the aggregations won't get hit.</span></span> <span data-ttu-id="71653-277">ซึ่งจะแตกต่างจากการใช้การรวมอิงตามความสัมพันธ์ ที่ซึ่งรายการ GroupBy เป็นตัวเลือก</span><span class="sxs-lookup"><span data-stu-id="71653-277">This is different from using aggregations based on relationships, where the GroupBy entries are optional.</span></span>

<span data-ttu-id="71653-278">ตารางต่อไปนี้จะแสดงการรวมตาราง **Driver Activity Agg**</span><span class="sxs-lookup"><span data-stu-id="71653-278">The following table shows the aggregations for the **Driver Activity Agg** table.</span></span>

![ตารางการรวม Driver Activity Agg](media/desktop-aggregations/aggregations-table_02.jpg)

<span data-ttu-id="71653-280">คุณสามารถตั้งค่าโหมดที่เก็บข้อมูลของตาราง **Driver Activity Agg** รวมไปเป็นโหมดนำเข้าได้</span><span class="sxs-lookup"><span data-stu-id="71653-280">You can set the storage mode of the aggregated **Driver Activity Agg** table to Import.</span></span>

### <a name="groupby-aggregation-query-example"></a><span data-ttu-id="71653-281">ตัวอย่างคิวรีการรวม GroupBy</span><span class="sxs-lookup"><span data-stu-id="71653-281">GroupBy aggregation query example</span></span>

<span data-ttu-id="71653-282">คิวรีต่อไปนี้จะเกิดการรวมข้อมูล เนื่องจากตารางการรวมครอบคลุมคอลัมน์ **Activity Date(วันกิจกรรม)**</span><span class="sxs-lookup"><span data-stu-id="71653-282">The following query hits the aggregation, because the **Activity Date** column is covered by the aggregation table.</span></span> <span data-ttu-id="71653-283">ฟังก์ชัน COUNTROWS ใช้การรวมแบบ **Count table rows**</span><span class="sxs-lookup"><span data-stu-id="71653-283">The COUNTROWS function uses the **Count table rows** aggregation.</span></span>

![คิวรีการรวม GroupBy ที่สำเร็จ](media/desktop-aggregations/aggregations-code_08.jpg)

<span data-ttu-id="71653-285">โดยเฉพาะอย่างยิ่งสำหรับแบบจำลองที่มีแอตทริบิวต์ตัวกรองในตารางเท็จจริง คุณควรใช้การรวมแบบ **Count table rows**</span><span class="sxs-lookup"><span data-stu-id="71653-285">Especially for models that contain filter attributes in fact tables, it's a good idea to use **Count table rows** aggregations.</span></span> <span data-ttu-id="71653-286">Power BI สามารถส่งคิวรี่ไปยังชุดข้อมูลโดยใช้ COUNTROWS ในกรณีที่ผู้ใช้ไม่ได้ร้องขออย่างชัดแจ้ง</span><span class="sxs-lookup"><span data-stu-id="71653-286">Power BI may submit queries to the dataset using COUNTROWS in cases where it is not explicitly requested by the user.</span></span> <span data-ttu-id="71653-287">ตัวอย่างเช่น กล่องโต้ตอบตัวกรองจะแสดงจำนวนแถวสำหรับแต่ละค่า</span><span class="sxs-lookup"><span data-stu-id="71653-287">For example, the filter dialog shows the count of rows for each value.</span></span>

![กล่องโต้ตอบตัวกรอง](media/desktop-aggregations/aggregations-12.png)

## <a name="combined-aggregation-techniques"></a><span data-ttu-id="71653-289">เทคนิคการรวมที่ผสมผสาน</span><span class="sxs-lookup"><span data-stu-id="71653-289">Combined aggregation techniques</span></span>

<span data-ttu-id="71653-290">คุณสามารถผสมผสานเทคนิคของความสัมพันธ์และคอลัมน์ GroupBy สำหรับการรวมข้อมูลได้</span><span class="sxs-lookup"><span data-stu-id="71653-290">You can combine the relationships and GroupBy columns techniques for aggregations.</span></span> <span data-ttu-id="71653-291">การรวมที่อิงตามความสัมพันธ์อาจต้องมีการแบ่งแยกตารางมิติข้อมูลที่ผ่านการดีนอร์มอลไลเซชั่นไปเป็นตารางหลายรายการ</span><span class="sxs-lookup"><span data-stu-id="71653-291">Aggregations based on relationships may require the denormalized dimension tables to be split into multiple tables.</span></span> <span data-ttu-id="71653-292">หากเป็นค่าใช้จ่ายหรือไม่เป็นประโยชน์สำหรับตารางมิติข้อมูลบางตาราง คุณสามารถทำซ้ำแอตทริบิวต์ที่จำเป็นในตารางการรวมสำหรับมิติข้อมูลบางมิติ และใช้ความสัมพันธ์สำหรับอันอื่นได้</span><span class="sxs-lookup"><span data-stu-id="71653-292">If this is costly or impractical for certain dimension tables, you can replicate the necessary attributes in the aggregation table for those dimensions, and use relationships for others.</span></span>

<span data-ttu-id="71653-293">ตัวอย่างเช่น แบบจำลองต่อไปนี้ทำซ้ำ **Month(เดือน)** , **Quarter(ไตรมาส)** , **Semester(เทอม)** และ **Year(ปี)** ในตาราง **Sales Agg**</span><span class="sxs-lookup"><span data-stu-id="71653-293">For example, the following model replicates **Month**, **Quarter**, **Semester**, and **Year** in the **Sales Agg** table.</span></span> <span data-ttu-id="71653-294">ไม่มีความสัมพันธ์ระหว่างตาราง **Sales Agg** และตาราง **Date** แต่มีความสัมพันธ์กับ **Customer** และ **Product Subcategory**</span><span class="sxs-lookup"><span data-stu-id="71653-294">There is no relationship between **Sales Agg** and the **Date** table, but there are relationships to **Customer** and **Product Subcategory**.</span></span> <span data-ttu-id="71653-295">โหมดพื้นที่เก็บข้อมูลของ **Sales Agg** คือ Import(การส่งออก)</span><span class="sxs-lookup"><span data-stu-id="71653-295">The storage mode of **Sales Agg** is Import.</span></span>

![เทคนิคการรวมที่ผสมผสาน](media/desktop-aggregations/aggregations_15.jpg)

<span data-ttu-id="71653-297">ตารางต่อไปนี้แสดงรายการที่ตั้งค่าไว้ในกล่องโต้ตอบ **Manage aggregations** สำหรับตาราง **Sales Agg{**</span><span class="sxs-lookup"><span data-stu-id="71653-297">The following table shows the entries set in the **Manage aggregations** dialog for the **Sales Agg** table.</span></span> <span data-ttu-id="71653-298">รายการ GroupBy ที่ **Date** เป็นตารางรายละเอียดมีผลบังคับให้เกิดการรวมสำหรับคิวรีที่จัดกลุ่มตามแอตทริบิวต์ **Date**</span><span class="sxs-lookup"><span data-stu-id="71653-298">The GroupBy entries where **Date** is the detail table are mandatory, to hit aggregations for queries that group by the **Date** attributes.</span></span> <span data-ttu-id="71653-299">ดังในตัวอย่างก่อนหน้า รายการ **GroupBy** สำหรับ **CustomerKey** และ **ProductSubcategoryKey** ไม่ส่งผลกระทบต่อการทำให้เกิดการรวม ยกเว้น DISTINCTCOUNT เนื่องจากการมีอยู่ของความสัมพันธ์</span><span class="sxs-lookup"><span data-stu-id="71653-299">As in the previous example, the **GroupBy** entries for **CustomerKey** and **ProductSubcategoryKey** don't affect aggregation hits, except for DISTINCTCOUNT, because of the presence of relationships.</span></span>

![รายการสำหรับตารางการรวม Sales Agg](media/desktop-aggregations/aggregations-table_04.jpg)

### <a name="combined-aggregation-query-examples"></a><span data-ttu-id="71653-301">ตัวอย่างคิวรีการรวมที่ผสมผสาน</span><span class="sxs-lookup"><span data-stu-id="71653-301">Combined aggregation query examples</span></span>

<span data-ttu-id="71653-302">คิวรีต่อไปนี้ทำให้เกิดการรวม เนื่องจากตารางการรวมครอบคลุม **CalendarMonth** และ **CategoryName** ได้ผ่านทางความสัมพันธ์แบบหนึ่งต่อกลุ่ม</span><span class="sxs-lookup"><span data-stu-id="71653-302">The following query hits the aggregation, because the aggregation table covers **CalendarMonth**, and **CategoryName** is accessible via one-to-many relationships.</span></span> <span data-ttu-id="71653-303">**SalesAmount** ใช้การรวมข้อมูลแบบ **Sum**</span><span class="sxs-lookup"><span data-stu-id="71653-303">**SalesAmount** uses the **SUM** aggregation.</span></span>

![ตัวอย่างคิวรีที่ทำให้เกิดการรวม](media/desktop-aggregations/aggregations-code_09.jpg)

<span data-ttu-id="71653-305">คิวรีต่อไปนี้จะไม่ทำให้เกิดการรวมเนื่องจากตารางการรวม CalendarDay ไม่ครอบคลุม **CalendarDay**</span><span class="sxs-lookup"><span data-stu-id="71653-305">The following query doesn't hit the aggregation, because the aggregation table doesn't cover **CalendarDay**.</span></span>

![สกรีนช็อตแสดงข้อความของคิวรีที่ประกอบด้วย CalendarDay](media/desktop-aggregations/aggregations-code_10.jpg)

<span data-ttu-id="71653-307">คิวรีเวลาอัจฉริยะต่อไปนี้จะไม่เกิดการรวมเนื่องจากฟังก์ชัน DATESYTD สร้างตารางค่า **CalendarDay** และตารางการรวมไม่ครอบคลุม **CalendarDay**</span><span class="sxs-lookup"><span data-stu-id="71653-307">The following time-intelligence query doesn't hit the aggregation, because the DATESYTD function generates a table of **CalendarDay** values, and the aggregation table doesn't cover **CalendarDay**.</span></span>

![สกรีนช็อตแสดงข้อความของคิวรีที่ประกอบด้วยฟังก์ชัน DATESYTD](media/desktop-aggregations/aggregations-code_11.jpg)

## <a name="aggregation-precedence"></a><span data-ttu-id="71653-309">ลำดับความสำคัญของการรวม</span><span class="sxs-lookup"><span data-stu-id="71653-309">Aggregation precedence</span></span>

<span data-ttu-id="71653-310">ลำดับความสำคัญของการรวมช่วยให้สามารถสรุปตารางการรวมหลายรายการโดยใช้คิวรี่ย่อยรายการเดียว</span><span class="sxs-lookup"><span data-stu-id="71653-310">Aggregation precedence allows multiple aggregation tables to be considered by a single subquery.</span></span>

<span data-ttu-id="71653-311">ตัวอย่างต่อไปนี้เป็น [แบบจำลองผสมผสาน](desktop-composite-models.md) ที่ประกอบด้วยหลายแห่งข้อมูล:</span><span class="sxs-lookup"><span data-stu-id="71653-311">The following example is a [composite model](desktop-composite-models.md) containing multiple sources:</span></span>

- <span data-ttu-id="71653-312">ตาราง **Driver Activity** ของ DirectQuery ประกอบด้วยข้อมูล IoT มากกว่าหนึ่งพันล้านแถวที่มาจากระบบข้อมูลขนาดใหญ่</span><span class="sxs-lookup"><span data-stu-id="71653-312">The **Driver Activity** DirectQuery table contains over a trillion rows of IoT data sourced from a big-data system.</span></span> <span data-ttu-id="71653-313">ใช้สำหรับการคิวรี่แบบเจาะลึกเพื่อดูการอ่าน IoT แต่ละตัวในบริบทของตัวกรองที่มีการควบคุม</span><span class="sxs-lookup"><span data-stu-id="71653-313">It serves drillthrough queries to view individual IoT readings in controlled filter contexts.</span></span>
- <span data-ttu-id="71653-314">ตาราง **Driver Activity Agg** เป็นตารางรวมระดับกลางในโหมด DirectQuery</span><span class="sxs-lookup"><span data-stu-id="71653-314">The **Driver Activity Agg** table is an intermediate aggregation table in DirectQuery mode.</span></span> <span data-ttu-id="71653-315">มีแถวมากกว่าหนึ่งพันล้านแถวในคลังข้อมูล Azure SQL และได้รับการปรับให้เหมาะกับแหล่งที่มาโดยใช้ดัชนี columnstore</span><span class="sxs-lookup"><span data-stu-id="71653-315">It contains over a billion rows in Azure SQL Data Warehouse and is optimized at the source using columnstore indexes.</span></span>
- <span data-ttu-id="71653-316">ตารางนำเข้า **Driver Activity Agg2** มีระดับการปิดกั้นสูงเนื่องจากแอตทริบิวต์ group-by มีจำนวนคาร์ดินอลลิตี้ (Cardinality) น้อยและต่ำ</span><span class="sxs-lookup"><span data-stu-id="71653-316">The **Driver Activity Agg2** Import table is at a high granularity, because the group-by attributes are few and low cardinality.</span></span> <span data-ttu-id="71653-317">จำนวนแถวอาจต่ำถึงหนึ่งพันดังนั้นจึงสามารถใส่ลงในแคชในหน่วยความจำได้อย่างง่ายดาย</span><span class="sxs-lookup"><span data-stu-id="71653-317">The number of rows could be as low as thousands, so it can easily fit into an in-memory cache.</span></span> <span data-ttu-id="71653-318">แอตทริบิวต์เหล่านี้ถูกนำไปใช้กับแดชบอร์ดของผู้บริหารที่มีตำแหน่งสูง ดังนั้นคิวรี่ที่อ้างถึงแอตทริบิวต์ดังกล่าวควรเกิดขึ้นโดยเร็วที่สุด</span><span class="sxs-lookup"><span data-stu-id="71653-318">These attributes happen to be used by a high-profile executive dashboard, so queries referring to them should be as fast as possible.</span></span>

> [!NOTE]
> <span data-ttu-id="71653-319">ตารางการรวม DirectQuery ที่ใช้แหล่งข้อมูลที่แตกต่างกันกับตารางรายละเอียดจะได้รับการสนับสนุนเฉพาะเมื่อตารางการรวมมาจาก SQL Server, Azure SQL หรือแหล่งที่มาของคลังข้อมูล Azure SQL</span><span class="sxs-lookup"><span data-stu-id="71653-319">DirectQuery aggregation tables that use a different data source from the detail table are only supported if the aggregation table is from a SQL Server, Azure SQL, or Azure SQL Data Warehouse source.</span></span>

<span data-ttu-id="71653-320">ฟุตปริ้นท์ของหน่วยความจำของแบบจำลองนี้มีขนาดค่อนข้างเล็ก แต่จะปลดล็อกชุดข้อมูลขนาดใหญ่</span><span class="sxs-lookup"><span data-stu-id="71653-320">The memory footprint of this model is relatively small, but it unlocks a huge dataset.</span></span> <span data-ttu-id="71653-321">แสดงถึงสถาปัตยกรรมที่สมดุลเนื่องจากกระจายโหลดคิวรีผ่านส่วนประกอบของสถาปัตยกรรมที่ใช้ประโยชน์จากจุดแข็งของพวกเขา</span><span class="sxs-lookup"><span data-stu-id="71653-321">It represents a balanced architecture because it spreads the query load across components of the architecture, utilizing them based on their strengths.</span></span>

![ตารางสำหรับแบบจำลองที่มีฟุตฟริ้นท์ขนาดเล็กที่ปลดล็อกชุดข้อมูลขนาดใหญ่](media/desktop-aggregations/aggregations_13.jpg)

<span data-ttu-id="71653-323">กล่องโต้ตอบ **จัดการการรวมข้อมูล** สำหรับ **Driver Activity Agg2** ตั้งค่าเขตข้อมูล **Precedence** เป็น *10* ซึ่งสูงกว่าสำหรับ **Driver Activity Agg**</span><span class="sxs-lookup"><span data-stu-id="71653-323">The **Manage aggregations** dialog for **Driver Activity Agg2** sets the **Precedence** field to *10*, which is higher than for **Driver Activity Agg**.</span></span> <span data-ttu-id="71653-324">การตั้งค่าความสำคัญสูงยิ่งขึ้นหมายความว่าคิวรีที่ใช้การรวมจะพิจารณา **Driver Activity Agg2** ก่อน</span><span class="sxs-lookup"><span data-stu-id="71653-324">The higher precedence setting means queries that use aggregations will consider **Driver Activity Agg2** first.</span></span> <span data-ttu-id="71653-325">ซึ่งสามารถตอบคิวรีย่อยที่ไม่ระดับการปิดกั้นสูงได้โดย **Driver Activity Agg2** จะพิจารณา **Driver Activity Agg** แทน</span><span class="sxs-lookup"><span data-stu-id="71653-325">Subqueries that aren't at the granularity that can be answered by **Driver Activity Agg2** will consider **Driver Activity Agg** instead.</span></span> <span data-ttu-id="71653-326">คิวรี่รายละเอียดที่ไม่สามารถตอบได้จากตารางรวมแต่ละตารางจะถูกนำไปที่ **Driver Activity**</span><span class="sxs-lookup"><span data-stu-id="71653-326">Detail queries that cannot be answered by either aggregation table will be directed to **Driver Activity**.</span></span>

<span data-ttu-id="71653-327">ตารางที่ระบุไว้ในคอลัมน์ **ตารางรายละเอียด** คือ **Driver Activity** ไม่ใช่ **Driver Activity Agg** เนื่องจากไม่ได้รับอนุญาตให้ใช้การรวมแบบสายโซ่</span><span class="sxs-lookup"><span data-stu-id="71653-327">The table specified in the **Detail Table** column is **Driver Activity**, not **Driver Activity Agg**, because chained aggregations are not allowed.</span></span>

![สกรีนช็อตแสดงกล่องโต้ตอบจัดการการรวมที่มีลำดับความสำคัญที่ถูกเรียกออกมา](media/desktop-aggregations/aggregations_14.jpg)

<span data-ttu-id="71653-329">ตารางต่อไปนี้จะแสดงการรวมตาราง **Driver Activity Agg2**</span><span class="sxs-lookup"><span data-stu-id="71653-329">The following table shows the aggregations for the **Driver Activity Agg2** table.</span></span>

![ตารางการรวม Driver Activity Agg2](media/desktop-aggregations/aggregations-table_03.jpg)

## <a name="detect-whether-queries-hit-or-miss-aggregations"></a><span data-ttu-id="71653-331">ตรวจสอบว่าคิวรีที่ทำให้เกิดหรือไม่ทำให้เกิดการรวมข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-331">Detect whether queries hit or miss aggregations</span></span>

<span data-ttu-id="71653-332">SQL Profiler สามารถตรวจสอบว่าคิวรีจะถูกส่งกลับจากเอ็นจินที่จัดเก็บแคชในหน่วยความจำหรือถูกผลักไปยังแหล่งข้อมูลโดย DirectQuery</span><span class="sxs-lookup"><span data-stu-id="71653-332">SQL Profiler can detect whether queries are returned from the in-memory cache storage engine, or pushed to the data source by DirectQuery.</span></span> <span data-ttu-id="71653-333">คุณสามารถใช้กระบวนการนี้เพื่อตรวจสอบว่ามีการรวมเกิดขึ้นหรือไม่อีกด้วย</span><span class="sxs-lookup"><span data-stu-id="71653-333">You can use the same process to detect whether aggregations are being hit.</span></span> <span data-ttu-id="71653-334">สำหรับข้อมูลเพิ่มเติม โปรดดู [คิวรีที่ทำให้เกิดหรือไม่ทำให้เกิดแคช](desktop-storage-mode.md#queries-that-hit-or-miss-the-cache)</span><span class="sxs-lookup"><span data-stu-id="71653-334">For more information, see [Queries that hit or miss the cache](desktop-storage-mode.md#queries-that-hit-or-miss-the-cache).</span></span> 

<span data-ttu-id="71653-335">นอกจากนี้ SQL Profiler ยังมีเหตุการณ์ที่ขยาย `Query Processing\Aggregate Table Rewrite Query` อีกด้วย</span><span class="sxs-lookup"><span data-stu-id="71653-335">SQL Profiler also provides the `Query Processing\Aggregate Table Rewrite Query` extended event.</span></span>

<span data-ttu-id="71653-336">JSON snippet ต่อไปนี้แสดงตัวอย่างของผลลัพธ์ของเหตุการณ์เมื่อใช้การรวม</span><span class="sxs-lookup"><span data-stu-id="71653-336">The following JSON snippet shows an example of the output of the event when an aggregation is used.</span></span>

- <span data-ttu-id="71653-337">**matchingResult** แสดงว่าคิวรี่ย่อยใช้การรวมข้อมูล</span><span class="sxs-lookup"><span data-stu-id="71653-337">**matchingResult** shows that the subquery used an aggregation.</span></span>
- <span data-ttu-id="71653-338">**dataRequest** แสดงคอลัมน์ GroupBy และคอลัมน์รวมที่ใช้คิวรีย่อย</span><span class="sxs-lookup"><span data-stu-id="71653-338">**dataRequest** shows the GroupBy column(s) and aggregated column(s) the subquery used.</span></span>
- <span data-ttu-id="71653-339">**การแม็ปปิ้ง** แสดงคอลัมน์ในตารางรวมที่ถูกแมปไป</span><span class="sxs-lookup"><span data-stu-id="71653-339">**mapping** shows the columns in the aggregation table that were mapped to.</span></span>

![ผลลัพธ์ของเหตุการณ์เมื่อใช้การรวมข้อมูล](media/desktop-aggregations/aggregations-code_01.jpg)

## <a name="keep-caches-in-sync"></a><span data-ttu-id="71653-341">เก็บแคชให้ตรงกัน</span><span class="sxs-lookup"><span data-stu-id="71653-341">Keep caches in sync</span></span>

<span data-ttu-id="71653-342">การรวมข้อมูลที่รวมโหมดที่จัดเก็บแบบ DirectQuery, Import และ/หรือ Dual อาจส่งคืนข้อมูลที่แตกต่างกัน เว้นเสียว่าแคชในหน่วยความจำถูกซิงค์กับข้อมูลต้นทาง</span><span class="sxs-lookup"><span data-stu-id="71653-342">Aggregations that combine DirectQuery, Import, and/or Dual storage modes may return different data unless the in-memory cache is kept in sync with the source data.</span></span> <span data-ttu-id="71653-343">ตัวอย่างเช่น การดำเนินการคิวรีจะไม่ซ่อนปัญหาของข้อมูลโดยวิธีการกรองผลลัพธ์ DirectQuery ให้ตรงกับค่าที่เก็บไว้ในแคช</span><span class="sxs-lookup"><span data-stu-id="71653-343">For example, query execution won't attempt to mask data issues by filtering DirectQuery results to match cached values.</span></span> <span data-ttu-id="71653-344">มีการกำหนดเทคนิคเพื่อจัดการปัญหาดังกล่าว ณ แหล่งที่มา หากจำเป็น</span><span class="sxs-lookup"><span data-stu-id="71653-344">There are established techniques to handle such issues at the source, if necessary.</span></span> <span data-ttu-id="71653-345">การเพิ่มประสิทธิภาพให้เหมาะสมควรใช้เฉพาะในรูปแบบที่ไม่กระทบต่อความสามารถในการตอบสนองความต้องการทางธุรกิจของคุณ</span><span class="sxs-lookup"><span data-stu-id="71653-345">Performance optimizations should be used only in ways that don't compromise your ability to meet business requirements.</span></span> <span data-ttu-id="71653-346">เป็นความรับผิดชอบของคุณในการทราบกระแสข้อมูลของคุณ และโปรดออกแบบมาให้เหมาะสม</span><span class="sxs-lookup"><span data-stu-id="71653-346">It's your responsibility to know your data flows and design accordingly.</span></span> 

## <a name="next-steps"></a><span data-ttu-id="71653-347">ขั้นตอนถัดไป</span><span class="sxs-lookup"><span data-stu-id="71653-347">Next steps</span></span>

<span data-ttu-id="71653-348">สำหรับข้อมูลเพิ่มเติมเกี่ยวกับแบบจำลองผสมผสาน โปรดดู:</span><span class="sxs-lookup"><span data-stu-id="71653-348">For more information about composite models, see:</span></span>

- [<span data-ttu-id="71653-349">ใช้แบบจำลองแบบรวมใน Power BI Desktop</span><span class="sxs-lookup"><span data-stu-id="71653-349">Use composite models in Power BI Desktop</span></span>](desktop-composite-models.md)
- [<span data-ttu-id="71653-350">ใช้ความสัมพันธ์แบบกลุ่มต่อกลุ่มใน Power BI Desktop</span><span class="sxs-lookup"><span data-stu-id="71653-350">Apply many-to-many relationships in Power BI Desktop</span></span>](desktop-many-to-many-relationships.md)
- [<span data-ttu-id="71653-351">จัดการโหมดที่เก็บข้อมูลใน Power BI Desktop</span><span class="sxs-lookup"><span data-stu-id="71653-351">Manage storage mode in Power BI Desktop</span></span>](desktop-storage-mode.md)

<span data-ttu-id="71653-352">สำหรับข้อมูลเพิ่มเติมเกี่ยวกับ DirectQuery โปรดดู:</span><span class="sxs-lookup"><span data-stu-id="71653-352">For more information about DirectQuery, see:</span></span>

- [<span data-ttu-id="71653-353">เกี่ยวกับการใช้ DirectQuery ใน Power BI</span><span class="sxs-lookup"><span data-stu-id="71653-353">About using DirectQuery in Power BI</span></span>](../connect-data/desktop-directquery-about.md)
- [<span data-ttu-id="71653-354">แหล่งข้อมูล Power BI</span><span class="sxs-lookup"><span data-stu-id="71653-354">Power BI data sources</span></span>](../connect-data/power-bi-data-sources.md)
